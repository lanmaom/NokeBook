## CSS

### 布局方式

- 让不定宽高的元素水平居中

```css
/* 1. */
.father {
  position: relative;
}
.child {
  position: absolute;
  left: 50%;
  transfrom: translateX(-50%);
}

/* 2 table居中*/
.father {
  display: table;
}
.child {
  display: table-cell;
}

/* 3.flex居中 */
.father {
  display: flex;
  align-items: center;
}

/* 4.如果是块元素 */
.child {
  margin-left: auto;
  margin-right: auto;
}

/* 5.如果行内块,图片,文字,块元素 */
.father {
  text-align: center;
}
```

- 两边固定中间自适应

```html
<!-- 方法1.使用定位 -->
<style>
  .box {
    position: relative;
  }
  .left {
    position: absolute;
    width: 200px;
    left: 0;
  }
  .right {
    position: absolute;
    width: 200px;
    right: 0;
  }
  .center {
    margin-left: 200px;
    margin-right: 200px;
    width: 100%;
  }
</style>
<body>
  <div class="box">
    <div class="left"></div>
    <div class="center"></div>
    <div class="right"></div>
  </div>
</body>

<!-- 方法2. 使用浮动 -->
<style>
  .left {
    float: left;
  }
  .right {
    float: right;
  }
  .center {
    overflow: hidden;
  }
</style>
<body>
  <!-- 注意, 盒子的位置需要发生变化 -->
  <div class="box clearfix">
    <div class="left"></div>
    <div class="right"></div>
    <div class="center"></div>
  </div>
</body>
```

### 盒子模型

- 一种是 IE 盒子模型 border-box 宽或高 = content + border + padding
- 一种是标准盒子模型 content-box 宽或高 = content
  设置这两种盒子模型: `box-sizing: border-box/content-box;`

### BFC 块级格式化上下文

#### BFC 布局规则

- 内部的 BOX 会在垂直方向,一个接一个的放置
- box 垂直方向的距离是由 margin 决定的,属于同一 BFC 的两个相邻元素 margin 会重叠
- BFC 区域不会与 float box 重叠
- BFC 就是页面上一个隔离的容器,容器里面的子元素不会影响到外面的元素.反之也是如此
- 计算 BFC 的高度时,浮动元素也参与计算.
-

#### 哪些元素会生成 BFC

- float 不为 none
- position 不为 static/relative
- overflow 不为 visible
- display 的值为 table table-cell table-caption
- 根元素

#### 怎么防止 margin 重叠

- overflow:hidden;

#### 有哪些 BFC 应用

- 左侧/右侧固定,右侧/左侧 自适应

```html
<style>
  .left {
    float: left;
  }
  .right {
    overflow: hidden;
  }
</style>
```

### 弹性布局

- 水平对齐方式 align-items: flex-start | flex-end | center | space-between | space-around
- 垂直对齐方式 justify-content: flex-start | flex-end | center| baseline

## JS

### 介绍 DOM 的三个阶段

- 事件捕获
- 目标阶段
- 事件冒泡

### 封装事件监听和解绑的兼容写法

```js
var myEvent = {
  addEvent: function (ele, event, func) {
    if (window.addEventListener) {
      ele.addEventListener(event, func, false);
    } else if (window.attachEvent) {
      ele.attachEvent(event, func);
    } else {
      ele['on' + event] = func;
    }
  },
  removeEvent: function (ele, event, func) {
    if (window.removeEventListener) {
      ele.removeEventListener(event, func, false);
    } else if (window.detachEvent) {
      ele.detachEvent('on' + event, func);
    } else {
      ele['on' + event] = null;
    }
  },
};
```

#### 事件捕获的具体流程

- window => document => html => body => ... => 目标元素

#### event 对象有哪些常用应用

- 1.阻止默认事件 e.preventDefault()
- 2.阻止冒泡 e.stopPropagation()
- 3.阻止相同事件的其他侦听器 e.stopImmediatePropagation()
- 4.当前绑定事件的元素 e.currentTarget
- 5.当前被点击的元素 e.target

#### 自定义事件

```js
var event = new Event('custome');
ele.addEventListener('custome', function () {}, false);
ele.dispatchEvent(event); // dispatchEvent() 方法给节点派一个合成事件
```

### 原型与原型链

#### instanceof 的原理

- A instance B 是指 B.prototype 是否在 A 的原型链上(简单理解就是沿着 A 的**proto** 跟 B 的 prototype 寻找,如果能找到同一引用返回 true,否则返回 false)

- 示例

```js
fn.__proto__ === Function.prototype;
Object.__proto__ === Function.prototype;
// -------------------------------------
// Function是自身创建的
Function.__proto__ === Function.prototype;
// -------------------------------------
// Function.prototype 是对象 所以
Function.prototype.__proto__ === Object.prototype;
```

#### 原型链的继承

```js
// 1.普通继承
// 原理: 改变父类构造函数运行时的this指向
// 缺点: 只实现部分继承 ,父类原型对象上的属性/方法类取不到
function Person(name) {
  this.name = name;
}
function Ming() {
  Person.call(this, name);
}

// 2.借助原型链继承
// 原理: new Person() => Person.__proto__ === Ming.prototype => new Person() => new Person().__proto__ => new Person.prototype
// 缺点: 多个实例公用一个父类的实例对象,修改其中一个实例上的引用对象,会对其他造成影响
function Person(name) {
  this.name = name;
}
function Ming() {}
Ming.prototype = new Person();

// 3.组合继承
function Person(name) {
  this.name = name;
}
function Ming(name) {
  Person.call(this, name);
}
Ming.prototype = Person.prototype;

// 4.组合继承的完美解决方案
function Person(name) {
  this.name = name;
}
function Ming(name, age) {
  this.age = age;
  Person.call(this);
}
Ming.prototype = Object.create(Person.prototype);
Ming.prototype.constructor = Ming;
```

#### new 运算符实现机制

- 创建了一个新对象
- 将构造函数的作用域赋给新对象(让 this 指向了这个对象)
- 执行了构造函数(为这个新对象添加属性)
- 返回新对象

#### this 指向的问题

- 普通函数调用 this 执行 window
- 对象调用 this 指向 调用的这个对象
- new 构造函数 调用, this 指向 new 构造函数的实例
- setTimeout setInterval this 指向 window
- 箭头函数 ,this 指向上下文(context 也就是作用域)

#### 改变 this 指向

- call 使用 call(this, arg1,arg2,...) //会主动调用函数
- apply 使用 apply(this, [...]) //会主动调用函数
- bind 使用 bind(this) //不会主动调用函数

### 性能优化

#### 提升页面性能的方法

- 资源压缩合并,减少 http 请求
- 非核心代码异步加载
- 使用浏览器缓存
- 使用 CDN 缓存
- 预解析 DNS
- HTTP 优化,如使用语义化标签,避免重定向
- CSS 优化,如布局代码写在前面,根据需求加载网络字体,避免使用 css 表达式

#### 异步加载的方式

- async
- defer
- 动态脚本加载
  - var script = document.createElement('script')
  - script.type =
  - script.src =
  - document.querySelector('head').appendChild(script)

#### defer 与 async 的区别

- defer 是在 html 解析后才会执行,如果有多个, 按加载顺序依次执行

```js
// demo.js
// console.log('demo-js');
// -----------------
// demo1.js
// console.log('demo1-js');
// -----------------
// html结构
// <script src="./demo.js" defer></script>
// <script src="./demo1.js" defer></script>

// <script>
//   console.log('html-js');
// </script>

// 打印结果
// html-js
// demo-js
// demo1-js
```

- async 是在加载完成后立即执行,如果是多个,执行顺序与加载顺序无关

```js
// demo.js
// console.log('demo-js');
// -----------------
// demo1.js
// console.log('demo1-js');
// -----------------
// html结构
// <script src="./demo.js" async></script>
// <script src="./demo1.js" async></script>

// <script>
//   console.log('html-js');
// </script>

// 打印结果
/*
  html-js
  demo-js
  demo1-js
*/
// 或
/*
  html-js
  demo1-js
  demo-js
*/
```

#### 什么是浏览器缓存

- 资源文件在电脑磁盘上的备份

#### 缓存的分类

- 强缓存
  - 特点: 不请求,直接使用缓存
  - 相关 HTTP 头部字段:
    - Expires: 过期时间,是个绝对时间,下发的是服务器时间,比较用的是客户端时间,所有有偏差
    - Cache-control: 过期时间,是个相对时间,优先级高,以客户端的相对时间为准,浏览器拿到资源之后的多少时间内都不会再去服务器请求
- 协商缓存

  - 特点: 浏览器不确定备份是否过期,需要与服务器请求确认.
  - 相关 HTTP 头部字段:
    - 1.Last-Modified/if-Modified-Since 服务器下发时间,客户端请求时间是带上下发时间,服务器判断文件是否过期,存在的问题服务器下发时间难以定义
    - 2.Etag/if-None-Match: 服务器下发 hash 值,客户端请求时带上 hash 值,服务器判断文件是否过期,优先级高.

#### 什么是 CDN?

- 特点: 在不同的地方缓存内容,将用户的请求定到最合适的缓存服务器上去获取内容
- 优点: 解决 internet 网络拥堵,提高用户访问网络的相应速度

#### 预解析 DNS

- DNS 预解析会消耗前端的性能,优化建议: 减少 DNS 请求次数,进行 DNS 预解析
- 方式: 让具有此属性的域名自动在后台解析,从而减少用户的等待时间,提升用户体验

#### 如何开启 DNS 预解析

```html
<meta http-equiv="x-dns-prefetch-control" content="on" />
(强制打开a标签的DNS预解析,https下默认关闭)
<link rel="dns-prefetch" href="//lanmaom.com" />
```
